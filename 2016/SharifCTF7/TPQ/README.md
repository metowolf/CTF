# WriteUp

这是一道 RSA 的破解题目，大概是系统会随机生成 10 个大素数，然后由用户选定任意两个不同的素数（黑盒），然后指定 e=65537 对 flag 进行 RSA 加密，返回加密密文。

现在只知道公钥 (e,n) 中的 e，但是素数的编号却是可以自己指定的，所以可以从这里攻击。

首先我们作如下定义：
```
素数 P[i], i=1..10
模数 N[i,j] = N[j,i] = P[i]*P[j]
密文 C[i,j] = RSA(flag, e, N[i,j]) = (flag**e)%N[i,j]
```

构造两组数据：
```
C[1,i] = (flag**e) % N[1,i] = (flag**e) + Z[1,i]*P[1]*P[i]
C[1,j] = (flag**e) % N[1,j] = (flag**e) + Z[1,j]*P[1]*P[j]

从而 C[1,i]-C[1,j] = P[1] * (Z[1,i]*P[i]-Z[1,j]*P[j])
同样 C[1,i]-C[1,k] = P[1] * (Z[1,i]*P[i]-Z[1,k]*P[k])
```

可以观察到，对三组密文的差取公约数都会暴露一个素数，所以只要取六组密文就能进行攻击

```python
import math

# 广义欧几里得
def exgcd(a,b):
	if b==0:
		return 1,0,a
	else:
		x,y,q=exgcd(b,a%b)
		x,y=y,x-(a//b)*y
		return x,y,q
# 广义欧几里得求逆元
def inv(a,p):
	x,y,t=exgcd(a,p)
	if t==1:
		return (x+p)%p
	else:
		return -1
# C[1,2] C[1,3] C[1,4]
a=35248451088102897325201747384988307868596152046070318935600556864264176428178168631832281387807355624413475934734580436930831759500033953322682159189676941852280625625827746451617562539452110694138787962204193133260350716007734111234666067177855723946811288168117309355943840265361766527788918006357612828886
b=74666223109572371352434467002765203619010589200964486979676278903918879791223754359150379270085903166400176382232795290048114803965004235229653615769630430588603835086436206290960521487896805969183313981542885895300566025301710156912327324998316190165604044640066015941998646371688325975728120262647653359127
c=64962548385502358696600302124626625458345511671373359118520449581874624295778610579824409586416665109006952165116799035383790356817232996957580216280184577990096372516817672114523298215471562201651807414742586166026366364315463695761885604544297102738254691727914659760906597964009338400493768070371865228931
p=math.gcd(a-b,a-c) # 攻击出 P[1]
print('p=%d'%p)

# C[2,1] C[2,3] C[2,4]
a=35248451088102897325201747384988307868596152046070318935600556864264176428178168631832281387807355624413475934734580436930831759500033953322682159189676941852280625625827746451617562539452110694138787962204193133260350716007734111234666067177855723946811288168117309355943840265361766527788918006357612828886
b=53832216541355992864194959985946899323411416776290319183266666705247067391189606674477325311863426262411813313789919861853845881795187966365151352299190114498468044494825562509417667676448924235175917953159431553958173543242087154583210776169482708419505299938155406988727336436194732724690859927439142763813
c=42233765892697487791812713693511855174456383097671681241134786006063315923651547568203454919141180730800155794188625722366573833689249997489782271131342454196575459790177330694767537215542477726705684305554066306826082983941726328524919510797157408058428450270636002589613985439717977993611215999234356560036
q=math.gcd(a-b,a-c) # 攻击出 P[2]
print('q=%d'%q)

phi=(p-1)*(q-1)
e=65537

# 对密文 C[1,2] 解密
d=inv(e,phi)
m=pow(a,d,p*q)

# 打印 16 进制明文
print(hex(m))
```

最后把十六进制的明文转换成字符
```python
>>> bytes.fromhex('5368617269664354467b37633632663132653765366630386639663533363565343535383864333464387d').decode('utf-8')
'SharifCTF{7c62f12e7e6f08f9f5365e45588d34d8}'
```
得到 flag
